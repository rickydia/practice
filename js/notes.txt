INTRO
	Console
		def: a tool that devs use to record the output of their JS programs
			print?
		console.log() command used to print, or log, text to the console
			console.log("Hello!");

	Data types
		strings
			single or double quotes
		numbers
			ints or doubles; with NO quotes
		bools
			true/false; with NO quotes
		null
			represents the absence of value; with no quotes
		undefined


	Math operators
		add +
		subtract -
		multiply *
		divide /
		+=
		-=
		*=
		increment x++
		decrement x--

	Properties
		when you introduce a new piece of data into JS, the browser saves it as an instance of the data type
		def: instance - an individual case, or object, of a data type
		.length
			every string instance has a length property
			console.log('Hello'.length);

		def: method - functions for the instance
		.toUpperCase()
			// prints HELLO
			console.log('Hello'.toUpperCase());
		.startsWith()
			// prints true
			console.log('hey'.startsWith('h'));

		def: libraries - use libraries to use methods for instances that aren't necessarily declared

		comments
			// single line
			/* multi line */


VARIABLES
	two ways to declare variables
		let
			value can be reassigned
		const
			value cannot change

	string interpolation
		+ connects the strings being added together
			let pet = 'dog';
			console.log('I love my pet ' + pet);
			// prints 'I love my pet dog'

		${variable} allows you to insert variables directly into text
			// needs to be wrapped in backticks `${variable}`
			let pet = 'dog';
			console.log(`I own a pet ${pet}`);
			// prints 'I own a pet dog


CONTROL FLOW
	if/else statements
		if( ){   }
		else if( ){   }
		else{   }

	switch statements
			very similar to c++
				let groceryItem = 'papaya';
				switch (groceryItem) {
					case 'tomato':
						console.log('Tomatoes are $0.49');
						break;
					case 'lime':
						console.log('Limes are $1.49');
						break;
					case 'papaya':
						console.log('Papayas are $1.29');
						break;
					default:
						console.log('Invalid item');
						break;
				}

	ternary operator
		if(x){
			true;
		}
		else{
			false;
		}

		is the same as

		x ? true : false;

	true/false values
		equates to false
			false, 0, -0, "", '', null, undefined, NaN
		equates to true
			all variable that have been declafed and assigned

	===
		equal
	!==
		not equal
	<
		less than
	>
		greater than
	<=
		less than or equal to
	>=
		greater than or equal to
	!
		negation of truthiness
	&&
		and
	||
		or


FUNCTIONS
	// this type of function layout is known as arrow functions
	const function1 = () => {
		blah
	};
	const function2 = (parameter1, parameter2) => {
		return parameter1 + parameter2;
	};
	function1();
	console.log(function2(input1, input2));

		const function
			creates a variable with a given name
		=
			variable is set equal to a set of parentheses followed by an arrow token
		() =>
			indicates the variable stores a function
		parameter1, parameter2
			parameter inputted to function
			there can be as many parameters as needed
		{ };
			function body
		function1();
			function call
		input1, input2
			the input for function
		return
			returns the thing next to it

	Function Declaration
		a function that is bound to an identifier or name
		require the keyword 'function', a name, and a function body

		function square (number) {
			return number * number;
		}
		console.log(square(5));

	Function Expression
		similar to function declaration, except that identifier can be omitted
		typically stored in a variable

		const square = function (number) {
			return number * number;
		};

	Arrow Functions
		1. Functions that take a single parameter should not use parentheses. The code will still work, but it's better practice to omit the parentheses around single parameters. However, if a function takes zero or multiple parameters, parentheses are required.
		2. A function composed of a sole single-line block is automatically returned. The contents of the block should immediately follow the arrow => and the return keyword can be removed. This is referred to as implicit return.
		3. A function composed of a sole single-line block does not need brackets.

		const multiplyByNineFifths = (celsius) => {
			return celsius * (9/5);
		};
		const getFahrenheit = (celsius) => {
			return multiplyByNineFifths(celsius) + 32;
		};
		console.log('The temperature is ' + getFahrenheit(15) + '°F');

		can get refactored to:

		const multiplyByNineFifths = celsius => celsius * (9/5);
		const getFahrenheit = celsius => multiplyByNineFifths(celsius) + 32;
		console.log('The temperature is ' + getFahrenheit(15) + '°F');


SCOPE
	Block Scope
		if a variable is redefined within a lesser scope using let, it won't affect the value of that same variable outside of that scope
		const colorOfSky = () => {
			const dusk = true;
			let color = 'blue';
			if (dusk) {
				let color = 'pink';
				console.log(color); // pink
			}
			console.log(color); // blue
		};
		colorOfSky(); // blue
		console.log(color); // ReferenceError


ARRAYS
	arrays declared with const remain mutable
	can change contents of an array, but cannot reassign the variable name to a new array or other data type

	let letters = ['a', 'b', 'c'];
	console.log(letters);   //prints ['a', 'b', 'c']
	console.log(letters[1]);   // prints 'b'

	.length
		tells the length of the array
		letters.length;

	.push
		pushes to the back
		letters.push('d');

	.pop()
		removes item from back
		letters.pop();

	ton of other methods as well


LOOPS
	For Loops
		just like c++
		for(let i = 0; i < var.length; i++){
			blah;
		}

	While Loops
		while(condition){
			blah;
		}

	break is a thing here too


ITERATORS
	.forEach()
		executes the same code on each element of an array
		must be called upon an array
		any changes to the iterated array value won't be updated in the original array
		the return value is undefined

		let numbers = [1, 2, 3];
		numbers.forEach(function(num){
			console.log(num * num);
		});

		(function(num)){
			creates a fucntion that takes a single parameter, num, and opens the block of code for that function. since forEach is an iterator method, every element in nunmbers will be passed to this fucntion as an argument in place of num

		can also be written as:

		let numbers = [1, 2, 3];
		numbers.forEach(num => console.log(num * num));

	.map()
		like forEach, but creates a new array with changed values
		syntax almost identical to forEach, but creates a new array to it must be set equal to something

		let numbers = [1, 2, 3];
		let bigNumbers = numbers.map(function(num){
			return num * num;
		});

		let bigNumbers = numbers.map
			creates a new array in which the returned values of the .map() method will be saved and calls the .map() method on the array numbers
		(function(num){
			creates a function with a single parameter, num, that opens the block of code for that function
		return num * num;
			the code we wish to execute upon each element in the array. this will save each value from the numbers array squared to the bigNumbers array

		can also be written as:

		let numbers = [1, 2, 3];
		let bigNumbers = numbers.map(num => num * num);

	.filter()
		creates a new array based off of certain elements frmot eh original array that evaluate to truthy based on conditions written in the block of the method

		let numbers = [1, 2, 10];
		let bigNumbers = numbers.filter(function(num){
			return num > 5;
		});

		can also be rewritten as:

		let numbers = [1, 2, 10];
		let bigNumbers = numbers.filter(num => num > 5);


OBJECTS
	def: containers that can store data and functions

	let restaurant = {
		_name: 'Italian Bistro',
		_seatingCapacity: 120,
		_hasDineInSpecial: true,
		_entrees: ['Penne alla Bolognese', 'Chicken Cacciatore', 'Linguine Pesto'],
		openRestaurant: () => {
			if (this._hasDineInSpecial) {
				return 'Unlock the door, post the special on the board, then flip the open sign.';
			}
			else {
				return 'Unlock the door, then flip the open sign.';
			}
		},
		closeRestaurant() {
			return 'Lock the door, flip the open sign. We are closed.';
		},
		set seatingCapacity(newCapacity) {
			if (typeof newCapacity === 'number') {
				this._seatingCapacity = newCapacity;
				console.log(`${newCapacity} is valid input.`);
			}
			else {
				console.log(`Change ${newCapacity} to a number.`)
			}
		}
		get seatingCapacity() {
			console.log(`There are ${this._seatingCapacity} seats at Italian Bistro.`);
			return this._seatingCapacity;
		}
	};
	console.log(restaurant._entrees);
	console.log(restaurant['_entrees']);
	let food = '_entrees';
	console.log(restaurant[food]);
	console.log(restaurant.openRestaurant());
	restaurant.appetizers = ['Fried Calamari', 'Fries'];
	restaurant['desserts'] = ['Tiramisu', 'Cannoli'];
	restaurant.seatingCapacity = 150;
	const seats = restaurant.seatingCapacity;

	_                                        indicates a property or value should not be modified directly by ohter code
	{}                                       objects use curly braces
	_name, _entrees, etc.                    are all keys
	:                                        seperate keys from values with a colon
	value                                    on right of colon
	,                                        each key-value pair is seperated by comma
	openRestaurant: () =>	                   key-function pair. adds the openRestaurant method to restaurant
	closeRestaurant() {}                     same as above. creates a new method. this is best practice. only added in ES6
	this._hasDineInSpecial                   allows the method to operate based off of data inside of the same object
																						same as accessing restaurant.hasDineInSpecial
																						needs the this. bc otherwise it would be out of scope
	set seatingCapacity(newCapacity)         a setter method that sets a new value for the _seatingCapacity key
	get seatingCapacity()                    a getter method that logs something then returns the value saved to _seatingCapacity.
	restaurant._entrees                      uses dot notation to access the values of the keys
	restaurant['_entrees']                   same as dot notation
	restaurant[food]                         same as above, but uses a variable
	.openRestaurant()                        calls the method
	restaurant.appetizers                    adds the property appetizers to the restaurant object
	restaurant['desserts']                   same as above, but uses bracket notation
	.seatingCapacity = 150                   calls the setter method and sets _seatingCapacity to 150
	const seats = restaurant.seatingCapacity calls the getter method

	setter and getter methods
		defined with set and get
		used to set and get values within an object


CLASSES
	js is an object oriented language

	Constructor
		js calls the constructor() method every time it creates a new instance of a class

		class Dog {
			constructor(name) {
				this.name = name;
				this.behavior = 0;
			}
		}

	Instance
		an object that contains the property names and methods of a class, but with unique property values

		class Dog {
			constructor(name) {
				this.name = name;
				this.behavior = 0;
			}
		}
		const halley = new Dog('Halley'); // Create new Dog instance
		console.log(halley.name); // Log the name value saved to halley
		// Output: 'Halley'

	Method
		same syntax as objects, but you don't include commas between methods

		class Dog {
			constructor(name) {
				this._name = name;
				this._behavior = 0;
			}
			get name() {
				return this._name;
			}
			get behavior() {
				return this._behavior;
			}
			incrementBehavior() {
				this._behavior++;
			}
		}

	Method Calls
		syntax for calling methods and getters on an instance is the same as calling them on an object.
		append the instance with a period, then the property or method name.
		for methods, you must also add opening and closing parenthesis

		let nikko = new Dog('Nikko'); // Create dog named Nikko
		nikko.incrementBehavior(); // Add 1 to nikko instance's behavior
		let bradford = new Dog('Bradford'); // Create dog name Bradford
		console.log(nikko.behavior); // Logs 1 to the console
		console.log(bradford.behavior); // Logs 0 to the console

	Inheritance
		still a thing. very similar to c++. child classes inherit everything (properties, methods, etc.) from parent class

		//parent class
		class Animal {
			constructor(name) {
				this._name = name;
				this._behavior = 0;
			}
			get name() {
				return this._name;
			}
			get behavior() {
				return this._behavior;
			}
			incrementBehavior() {
				this._behavior++;
			}
		}
		//child class
		class Cat extends Animal {
			constructor(name, usesLitter) {
				super(name);
				this._usesLitter = usesLitter;
			}
			get usesLitter() {
				return this._usesLitter;
			}
		}
		//second child class
		class Dog extends Animal {
			constructor(name) {
				super(name);
			}
		}

		extends				this keyword makes the methods of the animal class available inside the cat class
										"a new class named Cat extend the Animal class"
		constructor		called when you create a new Cat object, accepts two args: name and usesLitter
		super					calls the contructor of the parent class. in this case, super(name) passes the name argument of the Cat class to the contructor of the Animal class.then the Animal constructor runs, it sets this._name = name; for the new Cat instances
										MUST ALWAYS CALL THE super METHOD BEFORE YOU USE THE this KEYWORD -- if you don't js will throw a reference error
		_usesLitter   a unique property to the Cat class
		usesLitter()  a method specific to the Cat class

	Static Methods
		a static method is a method that isn't available in individual instances of the class, but can only be called directly from the class (SEE EXAMPLE BELOW)

		class Animal {
			constructor(name) {
				this._name = name;
				this._behavior = 0;
			}
			static generateName() {
				const names = ['Angel', 'Spike', 'Buffy', 'Willow', 'Tara'];
				const randomNumber = Math.floor(Math.random()*5);
				return names[randomNumber];
			}
		}
		//returns a name
		console.log(Animal.generateName());
		//TypeError
		const tyson = new Animal('Tyson');
		tyson.generateName();


